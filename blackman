#!/bin/sh
################################################################################
#                ____                     _ __                                 #
#     ___  __ __/ / /__ ___ ______ ______(_) /___ __                           #
#    / _ \/ // / / (_-</ -_) __/ // / __/ / __/ // /                           #
#   /_//_/\_,_/_/_/___/\__/\__/\_,_/_/ /_/\__/\_, /                            #
#                                            /___/ team                        #
#                                                                              #
# blackman - Emerge for Blackarch                                              #
#                                                                              #
# FILE                                                                         #
# blackman.sh                                                                  #
#                                                                              #
# DATE                                                                         #
# 2013-12-20                                                                   #
#                                                                              #
# DESCRIPTION                                                                  #
# Download and compile packages as Emerge does                                 #
#                                                                              #
# AUTHOR                                                                       #
# nrz@nullsecurity.net                                                         #
#                                                                              #
################################################################################


# blackman version
VERSION="blackman v0.1"

# url blackarch repository
REMOTE_REPO="https://github.com/BlackArch/blackarch.git"

LOCAL_REPO="${HOME}/.blackarch"

# meta directory for metadata files
META="${LOCAL_REPO}/meta"

# world file to follow pkg installed
WORLD="${LOCAL_REPO}/meta/world"

# blackarch packages location
REPO_PKGS="${LOCAL_REPO}/packages"

# true / false
FALSE="0"
TRUE="1"

# return codes
SUCCESS="1337"
FAILURE="31337"

# verbose mode - default: quiet
VERBOSE="/dev/null"

# colors
WHITE="$(tput bold ; tput setaf 7)"
GREEN="$(tput setaf 2)"
RED="$(tput bold; tput setaf 1)"
YELLOW="$(tput bold ; tput setaf 3)"
NC="$(tput sgr0)" # No Color


wprintf() {
    fmt=$1
    shift
    printf "%s${fmt}%s\n" "${WHITE}" "$@" "${NC}"

    return "${SUCCESS}"
}

# print warning
warn()
{
    printf "%s[!] WARNING: %s%s\n" "${RED}" "${*}" "${NC}"

    return "${SUCCESS}"
}

# print error and exit
err()
{
    printf "%s[-] ERROR: %s%s\n" "${RED}" "${*}" "${NC}"

    return "${SUCCESS}"
}

# print error and exit
cri()
{
    printf "%s[-] CRITICAL: %s%s\n" "${RED}" "${*}" "${NC}"
    
    exit "${FAILURE}"
}


# usage and help
usage()
{
cat <<EOF
Usage: ${0} [options] | <misc>
OPTIONS:
    -s <pkg>: search package
    -i <pkg>: download and compile package
    -u: update system
    -d: download and update blackarch repository
EOF
    return "${SUCCESS}"
}


# leet banner, very important
banner()
{
    printf "%s--==[ blackman by nrz@nullsecurity.net ]==--%s\n" "${YELLOW}" "${NC}"

    return "${SUCCESS}"
}


# check argument count
check_argc()
{
    return "${SUCCESS}"
}


# check if required arguments were selected
check_args()
{
    return "${SUCCESS}"
}

# check if its first time for blackman and set everything up
check_init()
{
    printf "%s" "${WHITE}"
    # check blackarch repository
    if ! [ -d "${LOCAL_REPO}" ]; then  
        printf "[+] First Blackman Init - Setting up... \n"
        cd "${HOME}"
        git clone "${REMOTE_REPO}" "${LOCAL_REPO}"
    fi
    
    if ! [ -d "${META}" ]; then
        mkdir -p "${META}"
        printf "[+] Creating meta directory...\n"
    fi
    printf "%s" "${NC}"

    return "${SUCCESS}"
}


search()
{
    pkg=$1
    
    find "${REPO_PKGS}/" -name "*${pkg}*" | while read -r; do
        wprintf "[+] %s" "${REPLY##*/}"
    done

    return "${SUCCESS}"
}
      
install()
{
    pkg=$1
    if [ -d "${REPO_PKGS}/${pkg}" ]; then
        cd "${REPO_PKGS}/${pkg}"

        if [[ ${UID} -ne 0 ]]; then
            makepkg -sf
        else
            makepkg -sf --asroot
        fi

        [ "${?}" == "1" ] && cri "Something wrong with makepkg"
        sudo pacman -U *.xz

        # cleaning up
        # TODO: get the file that PKGBUILD download for rm
        rm -rf *.xz pkg/ src/ "${pkg}*"

        ! grep -q "${pkg}" "${WORLD}" && printf "%s\n" "${pkg}" >> "${WORLD}"
    else
        cri "Package not found in repository"
    fi

    return "${SUCCESS}"
}

update_repo()
{
    printf "%s" "${WHITE}"
    
    cd "${LOCAL_REPO}"
    git pull
    
    printf "%s" "${NC}"

    return "${SUCCESS}"
}

# parse command line options
get_opts()
{
    while getopts s:i:udvVH flags
    do
        case ${flags} in
            s)
                opt_mode="search"
                opt_arg=${OPTARG}
                ;;
            i)
                opt_mode="install"
                opt_arg=${OPTARG}
                ;;
            u)
                opt_mode="update"
                opt_arg=${OPTARG}
                ;;
            d)
                opt_mode="update_repo"
                ;;
            v)
                VERBOSE="/dev/stdout"
                ;;
            V)
                printf "%s\n" "${VERSION}"
                exit "${SUCCESS}"
                ;;
            H)
                usage
                ;;
            *)
                err "WTF?! mount /dev/brain"
                ;;
        esac
    done

    return "${SUCCESS}"
}


# controller and program flow
main()
{
    banner
    check_argc ${*}
    get_opts ${*}
    check_args ${*}
    check_init 

    case "${opt_mode}" in
        "search")
            search "${opt_arg}"
            ;;
        "install")
            install "${opt_arg}"
            ;;
        "update_repo")
            update_repo
            ;;
        *)
            usage
            ;;
    esac
    return "${SUCCESS}"
}


# program start
main ${*}

# EOF
